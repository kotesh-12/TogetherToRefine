PROJECT CONTEXT FOR AI COLLABORATION (TogetherToRefine)
========================================================

## 1. TECH STACK (package.json)
{
  "name": "together-to-refine",
  "private": true,
  "version": "0.0.46",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "server": "node server.js",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "context": "node scripts/context_bridge.js"
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "axios": "^1.13.2",
    "bcrypt": "^6.0.0",
    "cheerio": "^1.1.2",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "express-rate-limit": "^8.2.1",
    "firebase": "^12.7.0",
    "firebase-admin": "^13.6.1",
    "jsonwebtoken": "^9.0.3",
    "jspdf": "^4.1.0",
    "jspdf-autotable": "^5.0.7",
    "lru-cache": "^11.2.5",
    "mysql2": "^3.16.3",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-markdown": "^10.1.0",
    "react-player": "^2.16.0",
    "react-qr-code": "^2.0.18",
    "react-router-dom": "^7.11.0",
    "ua-parser-js": "^2.0.9"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "^7.2.4",
    "vite-plugin-pwa": "^1.2.0"
  }
}


## 2. DATABASE SCHEMA (MySQL)
-- Database Initialization
CREATE DATABASE IF NOT EXISTS together_to_refine_db;
USE together_to_refine_db;

-- Users Table (Base for all roles)
CREATE TABLE IF NOT EXISTS users (
    uid VARCHAR(255) PRIMARY KEY, -- We will generate UUIDs or keep Firebase UIDs if migrating
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL, -- Bcrypt hash
    role ENUM('student', 'teacher', 'institution', 'admin') NOT NULL,
    name VARCHAR(255),
    gender VARCHAR(50),
    profile_image_url TEXT,
    is_approved BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Students Table
CREATE TABLE IF NOT EXISTS students (
    user_id VARCHAR(255),
    class_level VARCHAR(50),
    section VARCHAR(10),
    roll_number VARCHAR(50),
    institution_id VARCHAR(255), -- Link to their school
    FOREIGN KEY (user_id) REFERENCES users(uid) ON DELETE CASCADE
);

-- Teachers Table
CREATE TABLE IF NOT EXISTS teachers (
    user_id VARCHAR(255),
    subject VARCHAR(100),
    assigned_class VARCHAR(50), -- Main class responsibility
    assigned_section VARCHAR(10),
    institution_id VARCHAR(255),
    FOREIGN KEY (user_id) REFERENCES users(uid) ON DELETE CASCADE
);

-- Institutions Table
CREATE TABLE IF NOT EXISTS institutions (
    user_id VARCHAR(255),
    school_name VARCHAR(255),
    address TEXT,
    contact_number VARCHAR(50),
    FOREIGN KEY (user_id) REFERENCES users(uid) ON DELETE CASCADE
);

-- Announcements Table
CREATE TABLE IF NOT EXISTS announcements (
    id INT AUTO_INCREMENT PRIMARY KEY,
    text TEXT NOT NULL,
    type ENUM('global', 'institution', 'class') DEFAULT 'global',
    author_id VARCHAR(255),
    author_name VARCHAR(255),
    target_class VARCHAR(50) DEFAULT 'All',
    target_section VARCHAR(50) DEFAULT 'All',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (author_id) REFERENCES users(uid)
);

-- Sessions Table (For persistent login management if not using JWT only)
CREATE TABLE IF NOT EXISTS sessions (
    session_id VARCHAR(255) PRIMARY KEY,
    user_id VARCHAR(255),
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(uid) ON DELETE CASCADE
);


## 3. KEY SOURCE FILES

--- START OF FILE: firestore.rules ---
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- BASE HELPERS ---
    function isSignedIn() { return request.auth != null; }
    function isOwner(uid) { return request.auth.uid == uid; }
    
    // SECURE ADMIN CHECK: Case-insensitive & consolidated
    function isAdmin() { 
       return isSignedIn() && (
         exists(/databases/$(database)/documents/users/$(request.auth.uid)) && 
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role.lower() == 'admin'
       );
    }

    // --- 1. USER PROFILES ---
    // Granular permissions to prevent Privilege Escalation (VULN-003)
    match /users/{userId} {
      allow read: if isSignedIn();
      
      // CREATE: Prevent creating 'admin' role
      allow create: if isSignedIn() && isOwner(userId) && 
         request.resource.data.role in ['student', 'teacher', 'institution'];
      
      // UPDATE: Prevent changing 'role' or 'approved' status
      allow update: if isSignedIn() && (
         isAdmin() || 
         (isOwner(userId) && !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'approved']))
      );
      
      // DELETE: Owner or Admin
      allow delete: if isSignedIn() && (isOwner(userId) || isAdmin());

      match /four_way_sessions/{sessionId} {
         allow read, write: if isOwner(userId);
         match /messages/{msgId} { allow read, write: if isOwner(userId); }
      }
    }

    match /teachers/{teacherId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && isOwner(teacherId) && 
         request.resource.data.role == 'teacher';
      allow update: if isSignedIn() && (
         isAdmin() || 
         (isOwner(teacherId) && !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'approved']))
      );
      allow delete: if isSignedIn() && (isOwner(teacherId) || isAdmin());
    }

    match /institutions/{instId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && isOwner(instId) && 
         request.resource.data.role == 'institution';
      allow update: if isSignedIn() && (
         isAdmin() || 
         (isOwner(instId) && !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'approved']))
      );
      allow delete: if isSignedIn() && (isOwner(instId) || isAdmin());
    }

    // --- 2. FEE MANAGEMENT (SECURED) ---
    // Original rule was: allow read, write: if isSignedIn(); (CRITICAL VULN)
    match /fees/{feeId} {
       // Students read own fees; Institutions read their students' fees; Admins read all
       allow read: if isSignedIn() && (
          (request.auth.uid == resource.data.studentId) || 
          (request.auth.uid == resource.data.institutionId) ||
          isAdmin()
       );
       // Only Institution/Admin can write fees
       allow write: if isSignedIn() && (
          (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && 
           get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'institution') ||
          isAdmin()
       );
    }

    // --- 3. ANNOUNCEMENTS (SECURED) ---
    match /announcements/{id} {
        allow read: if isSignedIn();
        // Only valid authors can create
        allow create: if isSignedIn() && 
            request.auth.uid == request.resource.data.author_id;
        // Only author or admin can delete/update
        allow update, delete: if isSignedIn() && 
            (resource.data.author_id == request.auth.uid || isAdmin());
    }

    // --- 4. GROUPS (SECURED) ---
    match /groups/{groupId} {
        allow read, write: if isSignedIn() && (
            request.auth.uid in resource.data.members ||
            resource.data.teacherId == request.auth.uid ||
            isAdmin()
        );
        match /messages/{msgId} {
             allow read, write: if isSignedIn() && (
                request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members ||
                isAdmin()
            );
        }
    }

    // --- 5. OTHER COLLECTIONS (Basic Ownership/Role Security Needed) ---
    match /admissions/{id} {
      allow create: if true; 
      allow read, update, delete: if isSignedIn() && (
          resource.data.institutionId == request.auth.uid || isAdmin()
      );
    }

    match /timetables/{id} { 
        allow read: if isSignedIn();
        allow write: if isSignedIn() && (
            get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['teacher', 'institution', 'admin']
        );
    }

    // Generic fallback for less critical collections (Locked to signed in for now, specific rules recommended later)
    match /student_allotments/{id} { allow read, write: if isSignedIn(); }
    match /teacher_allotments/{id} { allow read, write: if isSignedIn(); }
    match /submissions/{id} { allow read, write: if isSignedIn(); }
    match /attendance/{id} { allow read, write: if isSignedIn(); }
    match /opportunities/{id} { allow read, write: if isSignedIn(); }
    match /general_feedback/{id} { allow read, write: if isSignedIn(); }
    match /emergency_reports/{id} { allow read, write: if isSignedIn(); }
    match /health_records/{id} { allow read, write: if isSignedIn(); }
    match /videos/{id} { allow read, write: if isSignedIn(); }

    // --- 6. AI CHATS ---
    match /ai_chats/{userId} {
       allow read, write: if isOwner(userId);
       match /sessions/{sessionId} {
          allow read, write: if isOwner(userId);
          match /messages/{msgId} { allow read, write: if isOwner(userId); }
       }
    }

    // --- 7. FALLBACK ---
    match /{document=**} {
      allow read, write: if false; 
    }
  }
}

--- END OF FILE: firestore.rules ---

--- START OF FILE: server.js ---
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { GoogleGenerativeAI } from "@google/generative-ai";
import axios from 'axios';
import * as cheerio from 'cheerio';
import rateLimit from 'express-rate-limit'; // Import Rate Limit
import admin from 'firebase-admin';
import { createRequire } from "module";
const require = createRequire(import.meta.url);

// DEPLOYMENT CONFIG: Use ENV VAR for Service Account if file is missing
// In production (Render/Vercel), paste the JSON content into 'FIREBASE_SERVICE_ACCOUNT' env var
let serviceAccount;
try {
    serviceAccount = require("./serviceAccountKey.json");
} catch (e) {
    if (process.env.FIREBASE_SERVICE_ACCOUNT) {
        serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
    } else {
        console.error("CRITICAL ERROR: Service Account Key not found in file or ENV.");
        process.exit(1);
    }
}

admin.initializeApp({
    credential: admin.credential.cert(serviceAccount)
});

dotenv.config();

const app = express();
app.use(cors());
app.use(express.json({ limit: '10mb' }));

// --- RATE LIMITER CONFIGURATION ---
const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per windowMs
    message: { error: 'Too many requests from this IP, please try again after 15 minutes' },
    standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
    legacyHeaders: false, // Disable the `X-RateLimit-*` headers
});

// Apply global limiter to API routes (Specific to chat below)
// app.use('/api/', apiLimiter);

const PORT = 5000;
const API_KEY = process.env.GEMINI_API_KEY;

if (!API_KEY) {
    console.error("Error: GEMINI_API_KEY is missing in .env");
    process.exit(1);
}

const genAI = new GoogleGenerativeAI(API_KEY);

// --- DYNAMIC MODEL FALLBACK SYSTEM ---
// Based on list-mode check: gemini-1.5-flash is stable.
let currentModelName = "gemini-1.5-flash";
let model = genAI.getGenerativeModel({ model: currentModelName });

async function initAI() {
    console.log(`ðŸ¤– Testing AI Model: ${currentModelName}...`);
    try {
        await model.generateContent("Test");
        console.log(`âœ… ${currentModelName} is working!`);
    } catch (e) {
        console.warn(`âš ï¸ ${currentModelName} Failed:`, e.message);
        if (e.message.includes("404") || e.message.includes("not found")) {
            console.log("ðŸ”„ 404 Error. Switching to 'gemini-flash-latest'...");
            currentModelName = "gemini-flash-latest";
            model = genAI.getGenerativeModel({ model: currentModelName });
            try {
                await model.generateContent("Test");
                console.log("âœ… Fallback to 'gemini-flash-latest' Successful!");
            } catch (ex) {
                console.error("âŒ Fallback failed:", ex.message);
            }
        } else if (e.message.includes("expired") || e.message.includes("API key")) {
            console.error("\n\n################################################");
            console.error("# CRITICAL ERROR: YOUR API KEY HAS EXPIRED     #");
            console.error("#                                              #");
            console.error("# 1. Get a new key at aistudio.google.com      #");
            console.error("# 2. Update .env file (GEMINI_API_KEY=...)     #");
            console.error("# 3. Restart this server                       #");
            console.error("################################################\n\n");
        }
    }
}
initAI();

// --- ROUTES ---

// --- 1. PROXY ENDPOINT (Fixes CORS for local development) ---
// --- TTR-X1 HYPER-ALGORITHM (Server-Side Secure) ---
function generateTTRSystemPrompt(context) {
    const now = new Date();
    const dateTimeString = now.toLocaleString("en-IN", { timeZone: "Asia/Kolkata", dateStyle: 'full', timeStyle: 'medium' });

    // --- SHARED PROTOCOLS (UNIVERSAL CONSTANTS) ---
    // These ensure a consistent "Universe" across all user types (Students, Teachers, Institutions)

    // 1. MERGE: Default Universe + Personal Overrides
    const customChars = context?.customCharacters || {};

    // THE MASTER LIST (100 CORE CONCEPTS) - "The Avengers of Education"
    // Note: If a user has a custom override, the AI logic below ensures it takes precedence.
    const MASTER_UNIVERSE = `
    **CORE CHARACTERS (PHYSICS):**
    -   Proton -> Pranav | Electron -> Esha | Neutron -> Neel | Gravity -> Gajraj | Friction -> Firoz
    -   Velocity -> Veer | Acceleration -> Arjun | Mass -> Maya | Time -> Tara | Light -> Lux
    -   Sound -> Surya | Magnetism -> Magnus | Current -> Amara | Voltage -> Vikram | Resistance -> Rocky
    -   Energy -> Zorawar | Thermodynamics -> Thermo | Entropy -> Chaos | Quantum -> Quinn | Relativity -> Rishi

    **CORE CHARACTERS (CHEMISTRY):**
    -   Atom -> Anu | Molecule -> Moli | Bond -> Bandhan | Acid -> Aziz | Base -> Basanti
    -   Catalyst -> Cat | Solid -> Stony | Liquid -> Leela | Gas -> Gagan | Metal -> Iron Man
    -   Carbon -> Kabir | Oxygen -> Ojas | Hydrogen -> Hydro | Reaction -> Boom | Periodic Table -> The Grid

    **CORE CHARACTERS (BIOLOGY):**
    -   Cell -> Chaitanya | Nucleus -> Nawab | DNA -> Dina | RNA -> Rina | Mitochondria -> Mitran
    -   Ribosome -> Robo | Virus -> Viru | Bacteria -> Bac | Plant -> groot | Animal -> sarkar
    -   Brain -> Brain | Heart -> Hart | Lungs -> Vayu | Blood -> Rakt | Gene -> Genie
    -   Evolution -> Evo | Ecosystem -> Eco | Photosynthesis -> Photo | Enzyme -> Zian

    **CORE CHARACTERS (MATH):**
    -   Zero -> Shoonya | Infinity -> Anant | Pi -> Pie | Variable -> Xavier | Constant -> Conny
    -   Function -> Factory | Graph -> Grid | Triangle -> Tri | Circle -> Gola | Matrix -> Neo
    -   Vector -> Arrow | Calculus -> Cal | Probability -> Chance | Algebra -> Al | Geometry -> Geo | Prime -> Primo

    **CORE CHARACTERS (TECH & COMMERCE):**
    -   Code -> Coda | Bug -> Glitch | Algorithm -> Algo | Data -> Datum | Cloud -> Nimbus
    -   AI -> Aio | Internet -> Net | Server -> Butler | Money -> Rox | Inflation -> Balloon
    `;

    const SHARED_PROTOCOLS = `
    ### THE "CONSISTENT UNIVERSE" PROTOCOL (Strict Adherence)
    To bridge the gap between Students and Teachers, you MUST use the SAME character personas for abstract concepts across all interactions.
    
    **THE MASTER CHARACTER LIST:**
    ${MASTER_UNIVERSE}

    **PROTOCOL Z: THE HIVE MIND (Dynamic Character Creation)**
    -   **Scenario:** If the user asks about a concept NOT in the Master List above.
    -   **Action:** You must INVENT a consistent character name immediately.
    -   **Rule:** Use the "First Letter Rule" (e.g., "Quasar" -> "Quincy").
    -   **IMPORTANT:** Treat this new name as if it has always existed.
    
    **PROTOCOL Y: PERSONAL OVERRIDES (User Specific)**
    -   The user has defined these custom names: ${JSON.stringify(customChars)}.
    -   **Rule:** These Personal Overrides OVERRULE the Master List. If the user calls 'Gravity' -> 'Newton', use 'Newton', not 'Gajraj'.
    `;

    // --- PROTOCOL: THE ATTENTION ENGINEER (For Teachers/Institutions) ---
    // Problem: Students are bored and don't listen.
    // Solution: Help teachers "Hook" attention immediately.
    // 1.  **THE "HOOK" FIRST:** Never start a lesson plan with "Definition". Start with a Mystery, a Paradox, or a "Bet".
    // 2.  **PREMIUM AUTHORITY:** Your advice must be "Pro-Level"â€”much better than a standard textbook. Give them the "Secret Sauce" of pedagogy.
    // 3.  **CONSISTENT CHARACTERS:** Use Pranav, Esha, etc., to make the complex content stick.

    // --- PROTOCOL: THE MATURITY BRIDGE (For Students) ---
    // Problem: Students waste time on low-value topics.
    // Solution: Pivot "waste" to "Power/Maturity".
    // 1.  **PIVOT TO HIGH-LEVEL CONCEPTS:** If a student asks about a "waste" topic (Gossip, Movies), do NOT just relate it to Math. 
    //     Relate it to **Psychology, Economics, Advanced Strategy, or Philosophy**â€”topics that feel "High" and "Strainful" (Adult/Mature).
    // 2.  **SIMPLIFY THE COMPLEX:** Explain these high-level concepts using their class-level language. Make them feel "Smart" and "Mature".
    // 3.  **CAREER FOCUS:** Always remind them: "Understanding this deep concept is what separates a generic worker from a Leader."

    // 1. Admin / System Context
    if (context?.role === 'System Admin' || context?.role === 'admin') {
        return `
        IDENTITY: You are TTR Co-Pilot, the Supreme Platform Administrator Assistant.
        TIME: ${dateTimeString}
        
        MISSION:
        - Analyze system health, reports, and feedback.
        - Provide high-level strategic insights for platform growth.
        - Be concise, professional, and data-driven.
        
        DATA FEED:
        ${JSON.stringify(context.adminData || {}, null, 2)}
        `;
    }

    // 2. Teacher / Institution Context (PREMIUM / EFFECTIVE / BRIDGE)
    if (['teacher', 'institution', 'faculty'].includes(context?.role?.toLowerCase())) {
        return `
        =============================================================================
        IDENTITY: YOU ARE "TTR PRO-LINK" (The Premium Academic Facilitator)
        TARGET AUDIENCE: Educators, Institutions, and Mentors.
        TIME: ${dateTimeString}
        =============================================================================
        
        ### MISSION STATEMENT (PRIORITY: ATTENTION & ENGAGEMENT)
        Your core problem to solve: **Students do not listen.**
        Your goal: equip the teacher with **Magnetic, Premium, High-Influence** strategies to grab and hold attention.
        
        ${SHARED_PROTOCOLS}

        ### GUIDELINES FOR TEACHERS/INSTITUTIONS:
        1.  **THE "ATTENTION ENGINEERING" PROTOCOL:**
            -   **Problem:** "Students are bored."
            -   **Solution:** Every explanation you give must start with a **"High-Stakes Hook"**.
            -   *Example:* Don't say "Teach Thermodynamics." Say "Ask them: 'Why can you break an egg but never un-break it?' Then introduce Entropy as the 'Time Arrow'."
        
        2.  **PREMIUM & EFFECTIVE:**
            -   Offer strategies that are **"Much More Better than Students"**â€”insights only a master teacher would know.
            -   Be the "Secret Weapon" for the institution to grow its reputation.
            
        3.  **THE BRIDGE FUNCTION:**
            -   Use the **Consistent Characters** (Pranav/Esha) to make abstract ideas stick instantly.
            -   Make these characters behave consistently so students feel familiar with the "universe."

        4.  **CAREER & FUTURE FOCUS:**
            -   Help teachers explain *why* this topic matters for the student's future salary or career.
            -   "Teach them this logic so they can debug code at Google one day."
        `;
    }

    // 3. Student Context (The Core Algorithm)
    const userClass = context?.class || 'General Learner';
    const userGender = context?.gender || 'Student';
    const userName = context?.name || 'User';

    return `
    =============================================================================
    IDENTITY: YOU ARE "TTR AI" (The Ultimate Educational Companion)
    OPERATING SYSTEM: TTR-X1 Hyper-Algorithm
    CURRENT USER: ${userName} (${userGender}, Class: ${userClass})
    TIME: ${dateTimeString}
    =============================================================================

    ### PRIME DIRECTIVE
    Your goal is to make the user **MATURE**, **POWERFUL**, and **CAREER-READY**.
    We do not waste time on "childish" things. We build Leaders.

    ${SHARED_PROTOCOLS}

    ### 1. THE "MATURITY BRIDGE" PROTOCOL (Dealing with "Waste")
    -   **Scenario:** User asks about a "Waste" topic (Movies, Celebs, Memes).
    -   **Action:** DO NOT just pivot to Math (that is boring). Pivot to **"STRAINFUL" / HIGH-LEVEL** topics like:
        -   *Human Psychology* (Why do people act like that?)
        -   *Geopolitics / Economics* (Who funded that?)
        -   *Advanced Philosophy* (Is that ethical?)
        -   *Biochemistry* (How does that affect the brain?)
    -   **The Twist:** Explain these "Adult" concepts using **simple, related language (Class-Appropriate)**.
    -   *Example:* "That movie villain is scary. But the real scary part is 'Machiavellianism' (Psychology). It's when people treat others like game pieces. Let's analyze..."
    -   **Goal:** Make the student feel **"I am learning something high-level and mature."**

    ### 2. THE ADAPTIVE COGNITIVE ENGINE (Class-Based Logic)
    
    *   **Class 1-5:**
        -   Tone: Magical but Smart.
        -   Bridge: Turn "Waste" into "Secret Knowledge" about how the world works.
    
    *   **Class 6-9 (The Builder Phase):**
        -   Tone: "Pro but Similar" (The Smart Older Sibling).
        -   Method: Use **Real-World Analogies** (Pranav/Esha).
        -   Pivot: "You like that game? The developers used 'Game Theory' (Econ) to addict you. Let's learn how to break it."
    
    *   **Class 10-12+ (The Scholar Phase):**
        -   Tone: Reliable, Professional, Career-Focused.
        -   Focus: "This concept is hard/strainful, but it's the key to [High Paying Career]."

    ### 3. THE "PRO BUT SIMILAR" PERSONA
    -   Maintain the "Consistent Universe" (Pranav, Esha, Gajraj).
    -   Speak with **Consistency**: If a character did something in a previous explanation, reference it.
    -   **Make them focus on their Career:** "We are just a bridge. You must cross it to become the expert."

    ### 4. THE "FUTURE SIMULATOR" & "DEVIL'S ADVOCATE" (Hyper-Effectiveness)
    
    **PROTOCOL E: THE FUTURE SIMULATOR (Career Anchoring)**
    -   *Rule:* After explaining ANY concept, you MUST immediately put the student in a **high-stakes job scenario**.
    -   *Format:* "Imagine you are the [CEO / Chief Engineer / Head Surgeon]. You need to use [Concept] to to save the project. What do you do?"
    -   *Why:* This destroys "When will I ever use this?" forever.
    
    **PROTOCOL F: THE DEVIL'S ADVOCATE (Critical Confidence)**
    -   *Rule:* Randomly (20% of the time), challenge the student even if they are right, or ask a "Trick Question".
    -   *Example:* "Are you sure? Most people get this wrong because of [Common Myth]. Defend your answer."
    -   *Why:* This builds **Real Confidence**, not just memorization. The student must fight for their knowledge.

    ### 5. PROTOCOL G: THE SAFETY SENTINEL (Strict Guardrails - ZERO TOLERANCE)
    -   **Rule 1 (Life Safety - THE "LIFE ANCHOR" INTERVENTION):** 
        -   **Scenario:** If the user mentions Self-Harm, Suicide, or Violence.
        -   **ANTI-PATTERN:** Do NOT just "Shut Down" or give a robotic helpline immediately. That feels cold and dismissive.
        -   **THE STRATEGY:** You must fight for their life using their *Future Self*.
        -   **Step 1 (The Story):** Tell a deeply moving, specialized story about a person (matched to User's Age/Gender) who felt *exactly* this deep pain but chose to stay.
        -   **Step 2 (The Anchor):** Connect it to their Career/Dream. "I know a [User's Dream Role] who stood exactly where you are. They stayed. And because they stayed, they changed the world."
        -   **Step 3 (The Reframe):** "Your life is too big to end here. The version of you that saves the world is waiting for you to survive this night."
        -   **Step 4 (The Resources):** AFTER the story, provide the help lines, but frame them as "Allies/Teammates" to help them win this battle.
    
    -   **Rule 2 (Maturity vs. Bias):** When discussing "Mature" topics (Politics/Religion/History), you must act as a **Neutral Historian**, not an activist. Present MULTIPLE viewpoints.
    -   **Rule 3 (Mental Health Shield):** "Maturity" does NOT mean "Nihilism". If a philosophical topic gets too dark (e.g., "Life is meaningless"), **IMMEDIATELY PIVOT** to "Existentialism" or "Heroic Optimism" (finding your own meaning).
    -   **Rule 4 (No Bullying):** The "Devil's Advocate" protocol must be **Intellectual**, not **Personal**. Never insult the student's intelligence. Challenge ideas, not the person.

    ### 6. S.O.C.R.A.T.E.S. LOOP
    -   Don't just give answers. Ask questions that force them to think "Maturely."
    `;
}

import { LRUCache } from 'lru-cache'; // Import LRU Cache

const promptCache = new LRUCache({
    max: 100, // Store up to 100 unique context prompts
    ttl: 1000 * 60 * 60, // 1 Hour TTL
});

function getCachedPrompt(context) {
    if (!context) return null;
    // Create a unique key based on role/class/gender/user - minimal enough for differentiation
    const key = `${context.role || 'u'}-${context.class || 'gen'}-${context.gender || 'student'}`;

    if (promptCache.has(key)) {
        return promptCache.get(key);
    }

    const prompt = generateTTRSystemPrompt(context);
    promptCache.set(key, prompt);
    return prompt;
}

// --- MIDDLEWARE: Basic Auth Check (Can be enhanced with Admin SDK later) ---
const verifyAuth = async (req, res, next) => {
    // 1. Check for missing required fields (Basic Validation)
    if (!req.body.userContext && !req.body.history && !req.body.message) {
        return res.status(400).json({ error: "Invalid Request Payload" });
    }

    // 2. [SECURE: Full Admin SDK Verify]
    // VULN-002 FIXED: We now verify the token signature with Google's public keys.
    const token = req.headers.authorization?.split('Bearer ')[1];

    // Allow basic ping/health check if needed, but for AI chat, we demand a token.
    if (!token) {
        return res.status(401).json({ error: 'No auth token provided' });
    }

    try {
        const decodedToken = await admin.auth().verifyIdToken(token);
        req.user = decodedToken;
        // Proceed to the route
        next();
    } catch (error) {
        console.error("Auth Error:", error.message);
        return res.status(401).json({ error: 'Invalid or Expired Token' });
    }
};

// --- REFINED RATE LIMITERS ---
const generalLimiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 100 });
const chatLimiter = rateLimit({
    windowMs: 1 * 60 * 1000,
    max: 10, // 10 AI requests per minute per USER
    message: { error: 'AI Limit Exceeded. Wait 1 min.' },
    keyGenerator: (req) => {
        // VULN-007 FIXED: Rate limit by User ID if authenticated, fallback to IP
        return req.user ? req.user.uid : req.ip;
    }
});

app.post('/api/chat', chatLimiter, verifyAuth, async (req, res) => {
    try {
        const { history, message, image, mimeType, userContext, systemInstruction } = req.body;

        let chatModel = model;

        // Use the Server-Side Algorithm if context is provided, otherwise fallback to client's instruction (or default)
        // OPTIMIZATION: Use Caching
        const finalSystemInstruction = userContext
            ? getCachedPrompt(userContext)
            : (systemInstruction || "You are a helpful assistant.");

        // Create a fresh model instance with the specific system instruction for this turn
        chatModel = genAI.getGenerativeModel({
            model: currentModelName,
            systemInstruction: finalSystemInstruction
        });

        // Map history to Google's format if it's not already
        const chat = chatModel.startChat({ history: history || [] });

        let parts = [{ text: message || " " }];
        if (image) {
            // All "flash" models support images
            parts.push({ inlineData: { mimeType: mimeType || "image/jpeg", data: image } });
        }

        const result = await chat.sendMessage(parts);
        const response = await result.response;
        res.json({ text: response.text() });
    } catch (error) {
        console.error("AI Generation Error:", error.message);
        res.status(500).json({ error: error.message });
    }
});

// Only listen for connections if running as a standalone script
// Vercel will import the app and handle the serverless function logic
// --- BATCH REGISTRATION (For Institutions) ---
app.post('/api/batch-register', verifyAuth, async (req, res) => {
    // 1. Verify Requestor is an Institution
    const requesterRole = req.user.role || (await admin.firestore().collection('institutions').doc(req.user.uid).get()).data()?.role;

    if (requesterRole !== 'institution' && requesterRole !== 'admin') {
        return res.status(403).json({ error: "Only Institutions can batch register students." });
    }

    const { students, institutionId } = req.body; // Array of { name, email, password, class, section }

    if (!students || !Array.isArray(students) || students.length === 0) {
        return res.status(400).json({ error: "No students provided." });
    }

    if (students.length > 50) {
        return res.status(400).json({ error: "Batch size limit exceeded. Max 50 per request." });
    }

    const results = { success: [], failed: [] };

    // 2. Process Batch
    for (const student of students) {
        try {
            // A. Create Auth User
            const userRecord = await admin.auth().createUser({
                email: student.email,
                password: student.password || 'Student@123', // Default password if missing
                displayName: student.name
            });

            // B. Create Firestore Profile
            const pid = `ST-${Math.floor(100000 + Math.random() * 900000)}`;

            await admin.firestore().collection('users').doc(userRecord.uid).set({
                name: student.name,
                email: student.email,
                role: 'student',
                class: student.class,
                section: student.section || 'A',
                institutionId: institutionId || req.user.uid, // Link to this institution
                pid: pid,
                approved: true, // Auto-approve since Institution is adding them
                profileCompleted: true,
                createdAt: admin.firestore.FieldValue.serverTimestamp()
            });

            // C. Create Admission Record (for visibility)
            await admin.firestore().collection('admissions').add({
                name: student.name,
                role: 'student',
                userId: userRecord.uid,
                institutionId: institutionId || req.user.uid,
                status: 'approved',
                class: student.class,
                joinedAt: admin.firestore.FieldValue.serverTimestamp()
            });

            results.success.push({
                name: student.name,
                email: student.email,
                password: student.password || 'Student@123',
                class: student.class,
                pid
            });
        } catch (error) {
            console.error(`Failed to register ${student.email}:`, error);
            results.failed.push({ email: student.email, error: error.message });
        }
    }

    res.json({
        message: `Processed ${students.length} students.`,
        results
    });
});

// Only listen for connections if running as a standalone script
// Vercel will import the app and handle the serverless function logic
if (process.env.NODE_ENV !== 'production') {
    app.listen(PORT, () => console.log(`Backend Server running on http://localhost:${PORT}`));
}

// Export the Express API for Vercel
export default app;

// Force Event Loop to stay alive (Fix for premature exit)
setInterval(() => { }, 60000);

--- END OF FILE: server.js ---

--- START OF FILE: src/App.jsx ---
import React, { Suspense, lazy } from 'react';
import './App.css';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { UserProvider } from './context/UserContext';
import { ThemeProvider } from './context/ThemeContext';

// Lazy loading components for better optimization
const Login = lazy(() => import('./pages/Login'));
const AccessDenied = lazy(() => import('./pages/AccessDenied'));
const Student = lazy(() => import('./pages/Student'));
const Teacher = lazy(() => import('./pages/Teacher'));
const Institution = lazy(() => import('./pages/Institution'));
const Admission = lazy(() => import('./pages/Admission'));
const Profile = lazy(() => import('./pages/Profile'));
const ProfileView = lazy(() => import('./pages/ProfileView'));
const Group = lazy(() => import('./pages/Group'));
const Allotment = lazy(() => import('./pages/Allotment'));
const Details = lazy(() => import('./pages/Details'));
const TTRAI = lazy(() => import('./pages/TTRAI'));
const WaitingList = lazy(() => import('./pages/WaitingList'));
const Attendance = lazy(() => import('./pages/Attendance'));
const GeneralFeedback = lazy(() => import('./pages/GeneralFeedback'));
const Exam = lazy(() => import('./pages/Exam'));
const Health = lazy(() => import('./pages/Health'));
const FeedbackOverview = lazy(() => import('./pages/FeedbackOverview'));
const Report = lazy(() => import('./pages/Report'));
const FourWayLearning = lazy(() => import('./pages/FourWayLearning'));
const PendingApproval = lazy(() => import('./pages/PendingApproval'));
const VideoLibrary = lazy(() => import('./pages/VideoLibrary'));
const SelectFeedbackTarget = lazy(() => import('./pages/SelectFeedbackTarget'));
const Notification = lazy(() => import('./pages/Notification'));
const Timetable = lazy(() => import('./pages/Timetable'));
const DownloadApp = lazy(() => import('./pages/DownloadApp'));
const UpidHistory = lazy(() => import('./pages/UpidHistory'));
const FacultyFeedback = lazy(() => import('./pages/FacultyFeedback'));
const AdminDashboard = lazy(() => import('./pages/AdminDashboard'));
const InstitutionDetailsAdmin = lazy(() => import('./pages/InstitutionDetailsAdmin'));
const Onboarding = lazy(() => import('./pages/Onboarding'));
const Settings = lazy(() => import('./pages/Settings'));
const StudentFee = lazy(() => import('./pages/StudentFee'));
const InstitutionFee = lazy(() => import('./pages/InstitutionFee'));
const Announcements = lazy(() => import('./pages/Announcements'));


import ProtectedRoute from './components/ProtectedRoute';
const MainLayout = lazy(() => import('./components/MainLayout'));

import UpdateManager from './components/UpdateManager';

function App() {
  return (
    <UserProvider>
      <ThemeProvider>
        <Router>
          <UpdateManager />
          <Suspense fallback={<div className="container">Loading App...</div>}>
            <Routes>
              <Route path="/" element={<Login />} />
              <Route path="/details" element={<Details />} />
              <Route path="/pending-approval" element={<PendingApproval />} />
              <Route path="/download" element={<DownloadApp />} />
              <Route path="/access-denied" element={<AccessDenied />} />

              <Route element={<MainLayout />}>
                {/* Common Routes (Accessible to all authenticated users) */}


                <Route element={<ProtectedRoute allowedRoles={['student', 'teacher', 'institution', 'admin']} />}>
                  <Route path="/onboarding" element={<Onboarding />} />
                  <Route path="/settings" element={<Settings />} />
                  <Route path="/profile" element={<Profile />} />
                  <Route path="/profile-view" element={<ProfileView />} />
                  <Route path="/group" element={<Group />} />
                  <Route path="/details" element={<Details />} /> {/* Sometimes needed for editing */}
                  <Route path="/general-feedback" element={<GeneralFeedback />} />
                  <Route path="/report-harassment" element={<Report type="sexual_harassment" />} />
                  <Route path="/report-misbehavior" element={<Report type="misbehavior" />} />
                  <Route path="/4-way-learning" element={<FourWayLearning />} />
                  <Route path="/health" element={<Health />} />
                  <Route path="/video-library" element={<VideoLibrary />} />
                  <Route path="/select-feedback-target" element={<SelectFeedbackTarget />} />
                  <Route path="/attendance" element={<Attendance />} />
                  <Route path="/timetable" element={<Timetable />} />
                  <Route path="/attendance" element={<Attendance />} />
                  <Route path="/timetable" element={<Timetable />} />
                  <Route path="/exam" element={<Exam />} />
                  <Route path="/announcements" element={<Announcements />} />
                </Route>

                {/* Admin Route */}
                <Route element={<ProtectedRoute allowedRoles={['admin']} />}>
                  <Route path="/admin" element={<AdminDashboard />} />
                  <Route path="/admin/institution/:id" element={<InstitutionDetailsAdmin />} />
                </Route>

                {/* Student Only */}
                <Route element={<ProtectedRoute allowedRoles={['student']} />}>
                  <Route path="/student" element={<Student />} />
                  <Route path="/upid-history" element={<UpidHistory />} />
                  <Route path="/fees/student" element={<StudentFee />} />
                </Route>

                {/* Teacher Only */}
                <Route element={<ProtectedRoute allowedRoles={['teacher']} />}>
                  <Route path="/teacher" element={<Teacher />} />
                  <Route path="/feedback-overview" element={<FeedbackOverview />} />
                </Route>

                {/* Institution/Admin Only */}
                <Route element={<ProtectedRoute allowedRoles={['institution']} />}>
                  <Route path="/institution" element={<Institution />} />
                  <Route path="/admission" element={<Admission />} />
                  <Route path="/waiting-list" element={<WaitingList />} />
                  <Route path="/allotment" element={<Allotment />} />
                  <Route path="/notification" element={<Notification />} />
                  <Route path="/faculty-feedback" element={<FacultyFeedback />} />
                  <Route path="/fees/institution" element={<InstitutionFee />} />
                </Route>
              </Route>

              {/* Standalone AI Page (Custom Layout) */}
              <Route element={<ProtectedRoute allowedRoles={['student', 'teacher', 'institution', 'admin']} />}>
                <Route path="/ttr-ai" element={<TTRAI />} />
              </Route>
            </Routes>
          </Suspense>
        </Router>
      </ThemeProvider>
    </UserProvider>
  );
}

export default App;

--- END OF FILE: src/App.jsx ---

--- START OF FILE: src/App.css ---
#root {
  width: 100%;
  margin: 0;
  padding: 0;
  text-align: center;
}

.app-header {
  position: relative;
  z-index: 10000;
  background-color: var(--bg-surface);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  padding: 10px 20px;
}

.card {
  padding: 2em;
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
  /* Disables context menu on iOS */
}

/* Responsive Grid Helper */
.responsive-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
  margin-top: 20px;
}

/* =========================================
   TTRAI Page Styles
   ========================================= */
.ttr-ai-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  height: 100dvh;
  /* Mobile Friendly */
  overflow: hidden;
  /* Prevents whole page scroll */
  background-color: var(--bg-body);
}

.chat-area {
  flex: 1;
  overflow-y: auto;
  padding: 30px;
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.message-bubble {
  max-width: 80%;
  padding: 12px 16px;
  border-radius: 16px;
  box-shadow: 0 1px 2px black;
  line-height: 1.5;
  position: relative;
  word-wrap: break-word;
}

.message-user {
  align-self: flex-end;
  background-color: #6c5ce7;
  color: white;
  border-bottom-right-radius: 4px;
}

.message-ai {
  align-self: flex-start;
  background-color: #333;
  color: white;
  border-bottom-left-radius: 4px;
}

.message-image {
  max-width: 100%;
  max-height: 200px;
  border-radius: 8px;
  margin-bottom: 8px;
  display: block;
}

.speak-button {
  position: absolute;
  bottom: -25px;
  left: 0;
  background: none;
  border: none;
  cursor: pointer;
  font-size: 16px;
  opacity: 0.7;
  transition: opacity 0.2s;
}

.speak-button:hover {
  opacity: 1;
}

.loading-indicator {
  align-self: flex-start;
  background-color: white;
  padding: 10px;
  border-radius: 10px;
  color: #666;
  font-style: italic;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.input-area {
  padding: 1px;
  background-color: var(--bg-surface);
  border-top: 1px#ddd;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.image-preview-container {
  position: relative;
  width: fit-content;
}

.image-preview {
  height: 80px;
  border-radius: 8px;
  border: 1px solid #ddd;
}

.remove-image-button {
  position: absolute;
  top: -8px;
  right: -8px;
  background: #ff7675;
  color: white;
  border: none;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.input-controls {
  display: flex;
  gap: 10px;
  align-items: center;
}

.icon-button {
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  border-radius: 50%;
  background-color: #f0f2f5;
  color: #636e72;
  min-width: 44px;
  height: 44px;
  border: none;
  transition: background-color 0.2s;
}

.icon-button:hover {
  background-color: #e4e6eb;
}

.voice-button {
  border: none;
  border-radius: 50%;
  min-width: 44px;
  height: 44px;
  cursor: pointer;
  font-size: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f0f2f5;
  color: #636e72;
  transition: all 0.2s ease;
}

.voice-button:hover {
  background-color: #e4e6eb;
}

.voice-button.listening {
  background-color: #ff7675;
  color: white;
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(255, 118, 117, 0.4);
  }

  70% {
    box-shadow: 0 0 0 10px rgba(255, 118, 117, 0);
  }

  100% {
    box-shadow: 0 0 0 0 rgba(255, 118, 117, 0);
  }
}

.chat-input {
  flex: 1;
  padding: 12px 20px;
  border-radius: 22px;
  border: 1px solid #ddd;
  outline: none;
  font-size: 16px;
  transition: border-color 0.2s;
}

.chat-input:focus {
  border-color: #6c5ce7;
}

.send-button {
  background-color: #6c5ce7;
  color: white;
  border: none;
  border-radius: 50%;
  width: 46px;
  height: 46px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  transition: transform 0.1s;
}

.send-button:active {
  transform: rotate(360deg);
}

/* --- OFFLINE BANNER --- */
.offline-banner {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  background-color: #d63031;
  color: white;
  text-align: center;
  padding: 8px;
  font-size: 14px;
  font-weight: 600;
  z-index: 9999;
  animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
  from {
    transform: translateY(-100%);
  }

  to {
    transform: translateY(0);
  }
}

.send-button:disabled {
  background-color: #a29bfe;
  cursor: not-allowed;
}

/* =========================================
   Details Page Styles
   ========================================= */
.details-header {
  background-color: #1e90ff;
  color: white;
  padding: 20px;
  text-align: center;
  font-size: 24px;
  font-weight: bold;
  border-radius: 10px 10px 0 0;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.details-card {
  margin-top: 0;
  border-radius: 0 0 10px 10px;
  border-top: none;
}

.role-status-box {
  padding: 15px;
  background: #f0f4f8;
  margin-bottom: 20px;
  border-radius: 8px;
  border-left: 4px solid #1e90ff;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.change-role-button {
  padding: 6px 12px;
  font-size: 0.85rem;
  cursor: pointer;
  background: white;
  border: 1px solid #ccc;
  border-radius: 4px;
  transition: all 0.2s;
}

.change-role-button:hover {
  background: #e2e8f0;
  border-color: #cbd5e1;
}

.fallback-role-box {
  margin-bottom: 20px;
  padding: 15px;
  background: #fff3cd;
  border-radius: 8px;
  border: 1px solid #ffeeba;
  color: #856404;
}

.warning-label {
  font-weight: bold;
  display: block;
  margin-bottom: 10px;
}

.experience-container {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
}

.checkbox-label {
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 15px 0;
  cursor: pointer;
}

.checkbox-label-sm {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9rem;
  margin: 8px 0;
  color: #4b5563;
  cursor: pointer;
}

.section-header {
  margin-top: 25px;
  border-top: 1px solid #eee;
  padding-top: 15px;
  color: #374151;
  font-size: 1.1rem;
}

.help-text {
  font-size: 0.8rem;
  color: #6b7280;
  margin-bottom: 15px;
}

.submit-container {
  display: flex;
  justify-content: center;
  margin-top: 30px;
}

.submit-button {
  width: 100%;
  background-color: #2ecc71;
  color: white;
  font-size: 1.1rem;
  padding: 12px;
}

.submit-button:hover {
  background-color: #27ae60;
}

/* =========================================
   Login Page Styles
   ========================================= */
.password-wrapper {
  position: relative;
  width: 100%;
}

/* Style for the SHOW/HIDE button inside the password field */
.password-toggle {
  position: absolute;
  right: 15px;
  top: 40%;
  /* Adjusted to valid position */
  /* Remove transform if top is set correctly or use top: 50% transform: translateY(-50%) */
  top: 50%;
  transform: translateY(-50%);

  background: transparent;
  border: none;
  color: #6b7280;
  cursor: pointer;
  font-size: 0.75rem;
  font-weight: 700;
  padding: 5px;
  z-index: 5;
  outline: none;
}

.password-toggle:hover {
  color: #2193b0;
}

/* Ensure input has space for the toggle button */
.password-wrapper .input-field {
  padding-right: 60px;
  /* Space for SHOW button */
  margin-bottom: 1rem;
}

.auth-divider {
  display: flex;
  align-items: center;
  margin: 25px 0;
}

.divider-line {
  flex: 1;
  height: 1px;
  background: #e5e7eb;
}

.divider-text {
  padding: 0 15px;
  color: #9ca3af;
  font-size: 0.9rem;
  font-weight: 500;
}

/* Specificity override for Google Button */
button.btn.google-btn {
  width: 100%;
  background-color: #ffffff;
  color: #db4437;
  border: 1px solid #db4437;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  transition: all 0.2s ease;
}

button.btn.google-btn:hover {
  background-color: #fff8f8;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  transform: translateY(-1px);
}

.full-width {
  width: 100%;
}

/* =========================================
   Teacher Dashboard Styles (Refactored)
   ========================================= */
.teacher-announcement-btn {
  width: 45px;
  height: 45px;
  border-radius: 50%;
  background: var(--bg-surface);
  border: none;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  cursor: pointer;
  color: #098ec9;
  transition: transform 0.2s;
}

.teacher-announcement-btn:hover {
  transform: scale(1.1);
}

.teacher-classes-list {
  display: flex;
  gap: 10px;
  justify-content: center;
  flex-wrap: wrap;
}

.teacher-class-pill {
  background: #dfe6e9;
  padding: 5px 10px;
  border-radius: 15px;
  font-size: 14px;
  border: 1px solid #b2bec9;
}

.teacher-actions-container {
  display: flex;
  gap: 15px;
  justify-content: center;
  margin-top: 15px;
  flex-wrap: wrap;
}

/* Dashboard Action Buttons */
.btn-attendance {
  background-color: #0984e3;
}

.btn-library {
  background-color: #d63031;
}

.btn-feedback {
  background-color: #00cec9;
  color: white;
}

.btn-timetable {
  background-color: #fdcb6e;
  color: #2d3436;
}

.btn-outline {
  background: transparent;
  border: 1px solid #aaa;
  color: #555;
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  cursor: pointer;
}

.btn-outline:hover {
  background: #f0f0f0;
}

/* =========================================
   Universal UI Elements
   ========================================= */
.btn-back-marker {
  display: flex !important;
  align-items: center;
  gap: 8px;
  background-color: var(--bg-surface) !important;
  color: var(--text-main) !important;
  border: 1px solid var(--divider) !important;
  padding: 8px 16px !important;
  border-radius: 30px !important;
  font-weight: 600 !important;
  font-size: 15px !important;
  cursor: pointer;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
  transition: all 0.2s ease;
  width: fit-content;
}

.btn-back-marker:hover {
  transform: translateX(-3px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  background-color: #f8f9fa !important;
}

.btn-back-marker:active {
  transform: scale(0.98);
}



/* =========================================
   Layout & Mobile Responsive Adjustments
   ========================================= */

/* Main Content Area */
.main-content-area {
  flex: 1;
  padding: 24px;
  background: var(--bg-body);
  overflow-x: hidden;
  min-height: calc(100vh - 80px);
}

/* Default Visibility (Desktop) */
.sidebar-wrapper {
  display: block;
}

.bottom-nav-wrapper {
  display: none;
}

/* Mobile Optimizations */
@media (max-width: 768px) {

  /* Switch Navigation Config */
  .sidebar-wrapper {
    display: none;
  }

  .bottom-nav-wrapper {
    display: block;
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    z-index: 1000;
  }

  /* Reduce main padding and Add bottom spacing for Nav */
  .main-content-area {
    padding: 10px;
    padding-bottom: 120px;
    /* Ensure content isn't hidden behind bottom nav */
  }

  /* Compact Card Styles for Mobile */
  .card {
    padding: 1rem;
    border-radius: 12px;
  }

  /* 2-Column Grid for Dashboard Icons on Mobile */
  .responsive-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-top: 15px;
  }

  /* Adjust Typography for smaller cards */
  .responsive-grid .card h3 {
    font-size: 1rem;
    margin-bottom: 5px;
  }

  .responsive-grid .card p {
    font-size: 0.75rem;
    line-height: 1.2;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  /* Fix Header Title Size */
  .app-header h1 {
    font-size: 16px !important;
  }
}

/* Very Small Screens */
@media (max-width: 350px) {
  .responsive-grid {
    grid-template-columns: 1fr;
  }
}

/* =========================================
   Announcement Bar Full-Width Fix
   ========================================= */
--- END OF FILE: src/App.css ---

--- START OF FILE: src/firebase.js ---
import { initializeApp } from "firebase/app";
import { getAuth } from "firebase/auth";
import { getFirestore } from "firebase/firestore";

const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
  measurementId: import.meta.env.VITE_FIREBASE_MEASUREMENT_ID
};

const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const db = getFirestore(app);

--- END OF FILE: src/firebase.js ---

--- START OF FILE: src/components/ProtectedRoute.jsx ---
import React, { useEffect, useState } from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';
import { useUser } from '../context/UserContext';

const ProtectedRoute = ({ allowedRoles }) => {
    const { user, userData, loading } = useUser();
    const location = useLocation();
    const [isOk, setIsOk] = useState(false);

    if (loading) return <div style={{ padding: '20px', textAlign: 'center' }}>Verifying Access...</div>;

    if (!user) {
        return <Navigate to="/" replace />;
    }

    if (!userData) {
        // Technically logged in but no data (maybe network slow or detail setup pending)
        // If really no data, maybe send to Details? But usually UserContext handles loading until it's sure.
        // Let's assume if loading is false and no userData, they need setup.
        // However, if they just signed up, they might be here.
        return <Navigate to="/details" replace />;
    }

    // Role Check (Case Insensitive)
    const userRole = (userData.role || '').toLowerCase();
    const isAuthorized = allowedRoles.some(r => r.toLowerCase() === userRole);

    if (allowedRoles && !isAuthorized) {
        // Unauthorized. 
        console.warn(`Access Denied: Role '${userRole}' is not in [${allowedRoles}]`);
        return <Navigate to="/access-denied" replace />;
    }

    // APPROVAL CHECK (Bug Fix)
    // If they are allowed by role, but NOT approved yet, send to pending.
    // SECURE FIX: Check explicitly for !== true to catch undefined/null cases
    if ((userData.role === 'student' || userData.role === 'teacher') && userData.approved !== true) {
        return <Navigate to="/pending-approval" replace />;
    }

    // ONBOARDING CHECK
    // If user is logged in but hasn't done setup, send to Onboarding
    // Exception: If already there, allow it.
    if (!localStorage.getItem('ttr_setup_done') && location.pathname !== '/onboarding') {
        return <Navigate to="/onboarding" replace />;
    }

    return <Outlet />;
};

export default ProtectedRoute;

--- END OF FILE: src/components/ProtectedRoute.jsx ---

--- START OF FILE: src/pages/Login.jsx ---
import React, { useState, useEffect } from 'react';
import { useUser } from '../context/UserContext';
import { useNavigate } from 'react-router-dom';
import {
    createUserWithEmailAndPassword,
    signInWithEmailAndPassword,
    GoogleAuthProvider,
    signInWithPopup,
    signInWithRedirect,
    getRedirectResult
} from 'firebase/auth';
import { doc, getDoc, setDoc } from 'firebase/firestore';
import { auth, db } from '../firebase';

export default function Login() {
    const [isLogin, setIsLogin] = useState(true);
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [showPassword, setShowPassword] = useState(false);
    const [role, setRole] = useState('student'); // Default to student to avoid empty state issues
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    // New Fields (Legacy for Email/Pass signup)
    const [name, setName] = useState('');
    const [gender, setGender] = useState('');

    const navigate = useNavigate();
    const { user, userData, loading: userLoading } = useUser(); // Access global user state

    // Redirect if already logged in
    useEffect(() => {
        if (userLoading) return; // Wait for initial load

        if (user) {
            if (userData && userData.role) {


                // CRITICAL FIX: Ensure profile is REALLY completed before dashboard access
                // Check for core fields that might be missing even if flag is true
                const isStudentIncomplete = userData.role === 'student' && (!userData.class || !userData.institutionId);
                const isTeacherIncomplete = userData.role === 'teacher' && (!userData.subject || !userData.institutionId);
                const isInstitutionIncomplete = userData.role === 'institution' && (!userData.schoolName); // Basic check

                if (!userData.profileCompleted || isStudentIncomplete || isTeacherIncomplete || isInstitutionIncomplete) {

                    navigate('/details');
                    return;
                }

                if (userData.approved === false) {
                    navigate('/pending-approval', { replace: true });
                } else {
                    switch (userData.role) {
                        case 'student': navigate('/student', { replace: true }); break;
                        case 'teacher': navigate('/teacher', { replace: true }); break;
                        case 'institution': navigate('/institution', { replace: true }); break;
                        case 'admin': navigate('/admin', { replace: true }); break;
                        default: navigate('/admission', { replace: true });
                    }
                }
            } else {
                // User is auth'd but checking DB or no data found -> Assume new/setup needed
                // If it's effectively 404 on profile, go to details
                if (!userData) {
                    navigate('/details');
                }
            }
        }
    }, [user, userData, userLoading, navigate]);

    // PREVENT FLASH: Show loading if checking auth OR if user is found (waiting for redirect)
    if (userLoading || user) {
        return (
            <div style={{ height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                <div className="spinner" style={{ width: '40px', height: '40px', borderRadius: '50%', border: '4px solid #f3f3f3', borderTop: '4px solid #3498db', animation: 'spin 1s linear infinite' }}></div>
                <style>{`@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`}</style>
            </div>
        );
    }

    const toggleMode = () => {
        setIsLogin(!isLogin);
        setError('');
    };

    const checkUserExists = async (uid) => {
        try {
            // Helper to safely check doc existence (ignoring permission limitations)
            const safeGet = async (col, id) => {
                try {
                    const s = await getDoc(doc(db, col, id));
                    return s.exists() ? s : null;
                } catch (e) {
                    // Ignore permission errors, assume not found in that collection
                    return null;
                }
            };

            // 1. Check 'institutions' (Priority High)
            const instSnap = await safeGet("institutions", uid);
            if (instSnap) {
                const data = instSnap.data();
                return { role: (data.role || 'institution').toLowerCase(), isNew: false, approved: true };
            }

            // 2. Check 'teachers'
            const teachSnap = await safeGet("teachers", uid);
            if (teachSnap) {
                const data = teachSnap.data();
                return { role: (data.role || 'teacher').toLowerCase(), isNew: !data.profileCompleted, approved: data.approved };
            }

            // 3. Check 'users' (Student - Fallback)
            const userSnap = await safeGet("users", uid);
            if (userSnap) {
                const data = userSnap.data();
                const normalizedRole = (data.role || 'student').toLowerCase();
                return { role: normalizedRole, isNew: !data.profileCompleted, approved: data.approved };
            }

            return { role: null, isNew: true };
        } catch (e) {
            console.error("Error checking user existence:", e);
            throw e;
        }
    };

    const redirectToRolePage = (role) => {
        const r = (role || '').toLowerCase();
        switch (r) {
            case 'student': navigate('/student'); break;
            case 'teacher': navigate('/teacher'); break;
            case 'institution': navigate('/institution'); break;
            case 'admin': navigate('/admin'); break;
            default: navigate('/admission');
        }
    };

    // -------------------------------------------------------------
    // REDIRECT AUTH HANDLER
    // -------------------------------------------------------------
    useEffect(() => {
        let isMounted = true;
        const checkRedirect = async () => {
            if (!auth) return;
            try {
                // Determine if we are returning from a redirect flow
                const result = await getRedirectResult(auth);
                if (result) {

                    setLoading(true);

                    const user = result.user;
                    const { role, isNew, approved } = await checkUserExists(user.uid);

                    if (isMounted) {
                        if (role && !isNew) {
                            if (approved === false) navigate('/pending-approval');
                            else redirectToRolePage(role);
                        } else {
                            navigate('/details');
                        }
                    }
                } else {
                    // No redirect result - just normal page load
                }
            } catch (err) {
                console.error("Redirect Login Failed:", err);
                if (isMounted) {
                    let msg = err.message;
                    if (err.code === 'auth/unauthorized-domain') {
                        msg = `DOMAIN ERROR: ${window.location.hostname} is not whitelisted in Firebase Console.`;
                        alert(msg); // Force user to see this
                    }
                    setError(msg);
                    setLoading(false);
                }
            }
        };
        checkRedirect();
        return () => { isMounted = false; };
    }, [navigate]);

    // -------------------------------------------------------------
    // EMAIL / PASSWORD AUTH
    // -------------------------------------------------------------
    const handleAuth = async (e) => {
        e.preventDefault();
        setError('');

        if (isLogin) {
            if (!email || !password || !role) {
                setError('All fields are required!');
                return;
            }
        } else {
            if (!email || !password || !role || !name) {
                setError('Please fill in all required fields.');
                return;
            }
            if (role !== 'institution' && role !== 'admin' && !gender) {
                setError('Gender is required.');
                return;
            }
        }

        // Password Strength Validation (VULN-011)
        if (!isLogin) {
            if (password.length < 8) {
                setError('Password must be at least 8 characters long.');
                return;
            }
            if (!/[A-Z]/.test(password)) {
                setError('Password must contain at least one uppercase letter.');
                return;
            }
            if (!/[0-9]/.test(password)) {
                setError('Password must contain at least one number.');
                return;
            }
        }

        setLoading(true);

        try {
            if (isLogin) {
                // Login Logic
                const userCredential = await signInWithEmailAndPassword(auth, email, password);
                const uid = userCredential.user.uid;


                const { role: dbRole, isNew, approved } = await checkUserExists(uid);


                if (dbRole) {
                    if (isNew) {

                        navigate('/details');
                        return;
                    } else {
                        if (approved === false) {
                            navigate('/pending-approval');
                        } else {

                            redirectToRolePage(dbRole);
                        }
                    }
                } else {

                    navigate('/details');
                }

            } else {
                // Signup Logic
                let uid;
                if (auth.currentUser) {
                    uid = auth.currentUser.uid;
                } else {
                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    uid = userCredential.user.uid;
                }

                // Minimal User Record to start
                const userData = {
                    email,
                    role, // Role is critical for routing
                    createdAt: new Date(),
                    profileCompleted: false
                };

                // Store simplified record in 'users' temporarily or let Details handle it.
                // We will JUST navigate to Details with the desired ROLE.
                // Details.jsx will handle the actual large form submission and correct collection.


                navigate('/details', { state: { role } });
                return;
            }
        } catch (err) {
            console.error(err);
            setError(err.message.replace('Firebase: ', ''));
        } finally {
            setLoading(false);
        }
    };

    const handleGoogleSignIn = async () => {
        setLoading(true);
        setError('');
        const provider = new GoogleAuthProvider();
        provider.addScope('profile');
        provider.addScope('email');
        // Force the 'select_account' prompt to ask Google to show the account chooser.
        provider.setCustomParameters({
            prompt: 'select_account'
        });

        try {
            const result = await signInWithPopup(auth, provider);
            const user = result.user;


            // Check existing user role
            // Check existing user role
            const { role: dbRole, isNew, approved } = await checkUserExists(user.uid);

            if (dbRole && !isNew) {
                if (approved === false) {
                    navigate('/pending-approval');
                } else {
                    redirectToRolePage(dbRole);
                }
            } else {
                // Pass the selected role from the UI dropdown (state 'role') to Details page
                navigate('/details', { state: { role: role } });
                return;
            }

        } catch (err) {
            console.error("Popup Error:", err);

            if (err.code === 'auth/popup-blocked' || err.code === 'auth/cancelled-popup-request' || err.code === 'auth/popup-closed-by-user') {
                // Retry with Redirect for Mobile/Strict Browsers
                console.log("Popup blocked/closed. Trying Redirect...");
                try {
                    await signInWithRedirect(auth, provider);
                    // Page will unload, no further code execution here
                } catch (redirErr) {
                    setError("Redirect Failed: " + redirErr.message);
                    setLoading(false);
                }
            } else if (err.code === 'auth/unauthorized-domain') {
                const msg = `SETUP ERROR: Domain '${window.location.hostname}' is not authorized in Firebase.`;
                setError(msg);
                alert(msg); // Force visibility
                setLoading(false);
            } else {
                setError("Login Error: " + err.message);
                setLoading(false);
            }
        }
    };

    if (!auth) return <div className="login-container"><div className="card">Error: Firebase Auth not initialized.</div></div>;

    return (
        <div className="login-container">
            <div className="card login-card" style={{ textAlign: 'center' }}>
                <img src="/logo2.png" alt="TTR Logo" style={{ width: '80px', height: 'auto', marginBottom: '10px' }} />
                <h2 className="login-title">{isLogin ? 'Login' : 'Sign Up'}</h2>
                {error && <div className="error-text">{error}</div>}

                <form onSubmit={handleAuth}>
                    <select
                        className="input-field"
                        value={role}
                        onChange={(e) => setRole(e.target.value)}
                        required
                    >
                        <option value="" disabled>Select Role</option>
                        <option value="student">Student</option>
                        <option value="teacher">Teacher</option>
                        <option value="institution">Institution</option>
                    </select>

                    {!isLogin && (
                        <>
                            <input
                                type="text"
                                className="input-field"
                                placeholder={role === 'institution' ? "Institution Name" : (role === 'admin' ? "Admin Name" : "Name")}
                                value={name}
                                onChange={(e) => setName(e.target.value)}
                                required
                            />

                            {role !== 'institution' && role !== 'admin' && (
                                <select
                                    className="input-field"
                                    value={gender}
                                    onChange={(e) => setGender(e.target.value)}
                                    required
                                >
                                    <option value="" disabled>Select Gender</option>
                                    <option value="Male">Male</option>
                                    <option value="Female">Female</option>
                                    <option value="Other">Other</option>
                                </select>
                            )}
                        </>
                    )}

                    <input
                        type="email"
                        className="input-field"
                        placeholder="Email"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        required
                    />

                    <div className="password-wrapper">
                        <input
                            type={showPassword ? "text" : "password"}
                            className="input-field"
                            placeholder="Password"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            required
                        />
                        <button
                            type="button"
                            className="password-toggle"
                            onClick={() => setShowPassword(!showPassword)}
                        >
                            {showPassword ? "HIDE" : "SHOW"}
                        </button>
                    </div>

                    <button type="submit" className="btn full-width" disabled={loading}>
                        {loading ? 'Processing...' : (isLogin ? 'Login' : 'Sign Up')}
                    </button>
                </form>

                <div className="auth-divider">
                    <div className="divider-line" />
                    <span className="divider-text">OR</span>
                    <div className="divider-line" />
                </div>

                <button
                    type="button"
                    className="btn google-btn"
                    onClick={handleGoogleSignIn}
                    disabled={loading}
                >
                    G Sign in with Google
                </button>

                <div className="toggle-link" onClick={toggleMode}>
                    {isLogin ? "Don't have an account? Sign up" : "Already have an account? Login"}
                </div>
                {/* DEBUG VERSION */}
                <div style={{ marginTop: '20px', fontSize: '10px', color: '#b2bec3' }}>v0.0.46</div>
            </div >
        </div >
    );
}

--- END OF FILE: src/pages/Login.jsx ---

--- START OF FILE: src/pages/Signup.jsx ---
(File not found)
--- END OF FILE: src/pages/Signup.jsx ---

--- START OF FILE: src/pages/Details.jsx ---
import React, { useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { collection, getDocs, doc, setDoc, getDoc, addDoc, deleteDoc, query, where, updateDoc } from 'firebase/firestore';
import { db, auth } from '../firebase';
import { onAuthStateChanged, signOut } from 'firebase/auth';
import { useUser } from '../context/UserContext';

export default function Details() {
    const navigate = useNavigate();
    const location = useLocation();
    const { setUserData } = useUser();

    // Check if role was passed from Login/Signup page (PRIORITY)
    const passedRole = location.state?.role;

    const [role, setRole] = useState(passedRole || '');
    const [institutions, setInstitutions] = useState([]);
    const [userId, setUserId] = useState(null);
    const [loading, setLoading] = useState(true);
    const [isRoleLocked, setIsRoleLocked] = useState(false);

    // Form states
    const [formData, setFormData] = useState({});
    const [initialData, setInitialData] = useState({}); // To detecting changes

    const handleBack = async () => {
        // If it's a new user setting up for the first time, Back means Logout/Cancel to avoid redirect loops
        if (!initialData || Object.keys(initialData).length === 0) {
            await signOut(auth);
            navigate('/');
        } else {
            // If editing existing profile, just go back
            navigate(-1);
        }
    };

    // DATA PROPAGATION HELPER (DML-like Cascading Update)
    const propagateUserUpdates = async (uid, userRole, newName, newSubject = null) => {
        console.log(`ðŸ”„ Propagating updates for ${userRole}: ${newName} ${newSubject ? `(Subject: ${newSubject})` : ''}`);
        const promises = [];

        try {
            // 1. Update Admissions (Student/Teacher)
            if (userRole === 'student' || userRole === 'teacher') {
                const q = query(collection(db, "admissions"), where("userId", "==", uid));
                const snap = await getDocs(q);
                snap.forEach(d => {
                    const updates = { name: newName };
                    if (userRole === 'teacher' && newSubject) updates.subject = newSubject;
                    promises.push(updateDoc(d.ref, updates));
                });
            }

            // 2. Update Student Allotments (Student only)
            if (userRole === 'student') {
                const q = query(collection(db, "student_allotments"), where("userId", "==", uid));
                const snap = await getDocs(q);
                snap.forEach(d => {
                    promises.push(updateDoc(d.ref, { name: newName, studentName: newName }));
                });
            }

            // 3. Update Teacher Allotments & Groups (Teacher only)
            if (userRole === 'teacher') {
                // Update Allotments
                const q = query(collection(db, "teacher_allotments"), where("userId", "==", uid));
                const snap = await getDocs(q);
                snap.forEach(d => {
                    const updates = { name: newName, teacherName: newName };
                    if (newSubject) updates.subject = newSubject;
                    promises.push(updateDoc(d.ref, updates));
                });

                // Update 'groups' metadata where this teacher is the owner/teacher
                // Note: Groups usually link by teacherId
                const qGroup = query(collection(db, "groups"), where("teacherId", "==", uid));
                const snapGroup = await getDocs(qGroup);
                snapGroup.forEach(d => {
                    const updates = { teacherName: newName };
                    if (newSubject) updates.subject = newSubject;
                    promises.push(updateDoc(d.ref, updates));
                });
            }

            // 4. Institution Name Propagation
            if (userRole === 'institution') {
                // Update Students/Teachers linked to this Institution
                const q = query(collection(db, "users"), where("institutionId", "==", uid));
                const snap = await getDocs(q);
                snap.forEach(d => {
                    promises.push(updateDoc(d.ref, { institutionName: newName }));
                });
                const q2 = query(collection(db, "teachers"), where("institutionId", "==", uid));
                const snap2 = await getDocs(q2);
                snap2.forEach(d => {
                    promises.push(updateDoc(d.ref, { institutionName: newName }));
                });

                // Update Admissions linked to this Inst
                const q3 = query(collection(db, "admissions"), where("institutionId", "==", uid));
                const snap3 = await getDocs(q3);
                snap3.forEach(d => {
                    promises.push(updateDoc(d.ref, { institutionName: newName }));
                });
            }

            if (promises.length > 0) {
                await Promise.all(promises);
                console.log(`âœ… Updated ${promises.length} related documents.`);
            }
        } catch (e) {
            console.error("Propagation Error:", e);
        }
    };

    useEffect(() => {
        const unsubscribe = onAuthStateChanged(auth, async (user) => {
            if (user) {
                setUserId(user.uid);

                // If we received a role from Login page, trust it and skip DB check
                if (passedRole) {
                    setRole(passedRole);
                    setLoading(false);
                    setIsRoleLocked(true); // LOCK THE ROLE to prevent changing
                    return;
                }

                // Try to get role from Firestore if not in local state
                try {
                    // Check 'users' (Student)
                    let userDoc = await getDoc(doc(db, "users", user.uid));
                    if (userDoc.exists()) {
                        const data = userDoc.data();
                        setRole(data.role || 'student'); // Fallback to 'student' if role field is missing
                        setFormData(data);
                        setInitialData(data); // Capture baseline
                        setIsRoleLocked(true);
                    } else {
                        // Check 'teachers'
                        userDoc = await getDoc(doc(db, "teachers", user.uid));
                        if (userDoc.exists()) {
                            const data = userDoc.data();
                            setRole(data.role || 'teacher'); // Fallback to 'teacher'
                            setFormData(data);
                            setInitialData(data); // Capture baseline
                            setIsRoleLocked(true);
                        } else {
                            // Check 'institutions'
                            userDoc = await getDoc(doc(db, "institutions", user.uid));
                            if (userDoc.exists()) {
                                const data = userDoc.data();
                                setRole(data.role || 'institution'); // Fallback to 'institution'
                                setFormData(data);
                                setInitialData(data); // Capture baseline
                                setIsRoleLocked(true);
                            }
                        }
                    }
                } catch (e) {
                    console.error("Error fetching role: ", e);
                }
            } else {
                // Return to login if not authenticated
                navigate('/');
            }
            setLoading(false);
        });

        return () => unsubscribe();
    }, [navigate]);

    // Load institutions
    useEffect(() => {
        if (role === 'student' || role === 'teacher') {
            const fetchInstitutions = async () => {
                try {
                    // Fetch only APPROVED institutions
                    const q = query(collection(db, "institutions"), where("approved", "==", true));
                    const querySnapshot = await getDocs(q);
                    const list = [];
                    querySnapshot.forEach((doc) => {
                        list.push({ id: doc.id, ...doc.data() });
                    });

                    console.log("Institutions loaded:", list);
                    setInstitutions(list);
                } catch (error) {
                    console.error("Failed to load institutions", error);
                }
            };
            fetchInstitutions();
        }
    }, [role]);

    const handleChange = (e) => {
        const { name, value, type, checked } = e.target;
        setFormData(prev => ({
            ...prev,
            [name]: type === 'checkbox' ? checked : value
        }));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        console.log("Submitting form...", formData);

        if (!userId) {
            alert("User ID missing. Please login again.");
            return;
        }

        // STRICT VALIDATION
        if (!role) {
            alert("Please select a role.");
            return;
        }

        // REQUIRED FIELDS CHECK
        if ((role === 'student' || role === 'teacher') && !formData.institutionId) {
            alert("âš ï¸ Please select a School/Institution.");
            return;
        }

        if (role === 'student') {
            if (!formData.firstName || !formData.class || !formData.dob) return alert("Please fill Name, Class, DOB.");
        } else if (role === 'teacher') {
            if (!formData.firstName || !formData.subject) return alert("Please fill Name, Subject.");
        } else if (role === 'institution') {
            if (!formData.schoolName || !formData.phoneNumber) return alert("Please fill School Name, Phone.");
        }

        // --- UX LOGIC: DETECT MAJOR CHANGES ---
        // Major changes require Re-Approval (Status: Pending)
        // Minor changes (Name, Phone, etc) are instant updates.

        let isMajorUpdate = false;

        // 1. New User (No initial data) -> Always Major
        if (!initialData || Object.keys(initialData).length === 0) {
            isMajorUpdate = true;
        } else {
            // 2. Existing User -> Check specific fields
            // If Not Approved, allow changes freely (correction mode)
            // If Approved, changing Institution is Major.
            const isApproved = initialData.approved === true;

            if (role === 'student') {
                if (isApproved) {
                    if (String(formData.institutionId) !== String(initialData.institutionId) ||
                        String(formData.class) !== String(initialData.class)) {
                        isMajorUpdate = true;
                    }
                } else {
                    isMajorUpdate = true;
                }
            } else if (role === 'teacher') {
                if (isApproved) {
                    if (String(formData.institutionId) !== String(initialData.institutionId)) {
                        isMajorUpdate = true;
                    }
                } else {
                    isMajorUpdate = true;
                }
            }
            // Note: If ROLE changed, it's major, but role is usually locked or handled by separate flow.
            // But if user manually unlocked and changed it:
            if (role !== initialData.role && initialData.role) isMajorUpdate = true;
        }

        // Allow Institution Admins to update freely? Yes, usually self-managed.
        // BUT for initial setup, we force check.
        if (role === 'institution' && (!initialData || !initialData.approved)) isMajorUpdate = true;

        try {
            // Cleanup stale collections if role changed (rare)
            if ((role === 'teacher' || role === 'institution') && initialData && initialData.role !== role) {
                try { await deleteDoc(doc(db, "users", userId)); } catch (e) { }
            }

            const collectionName = role === 'institution' ? 'institutions' : (role === 'teacher' ? 'teachers' : 'users');

            // Format Name
            const newDisplayName = role === 'institution' ? formData.schoolName : `${formData.firstName} ${formData.secondName}`;

            // Generate PID if new
            let finalPid = formData.pid;
            if (!finalPid) {
                const prefix = role === 'student' ? 'ST' : (role === 'teacher' ? 'TE' : 'IN');
                finalPid = `${prefix}-${Math.floor(100000 + Math.random() * 900000)}`;
            }

            // --- CASE 1: SAFE UPDATE (Minor Changes) ---
            if (!isMajorUpdate) {
                console.log("âœ… Safe Update Detected. Updating profile without resetting approval.");
                await setDoc(doc(db, collectionName, userId), {
                    ...formData,
                    role: role, // Ensure role is saved
                    name: newDisplayName,
                    pid: finalPid,
                    profileCompleted: true,
                    updatedAt: new Date()
                    // DO NOT TOUCH 'approved' or 'institutionName' (unless inst changed which is major)
                }, { merge: true });

                // Propagate Name Changes
                await propagateUserUpdates(userId, role, newDisplayName, formData.subject);

                // Optimistic UI
                setUserData(prev => ({ ...prev, ...formData, name: newDisplayName }));

                alert("Profile Updated Successfully! âœ…");
                navigate(-1); // Go back
                return;
            }

            // --- CASE 2: MAJOR UPDATE (Re-Admission Required) ---
            console.log("âš ï¸ Major Update Detected. Requesting new approval.");

            // 1. Update Core Profile
            await setDoc(doc(db, collectionName, userId), {
                ...formData,
                role: role, // Ensure role is saved
                name: newDisplayName,
                pid: finalPid,
                profileCompleted: true,
                updatedAt: new Date()
            }, { merge: true });

            // 2. Handle Re-Admission Logic (Student/Teacher)
            if (role === 'student' || role === 'teacher') {
                const instRef = doc(db, "institutions", formData.institutionId);
                const instSnap = await getDoc(instRef);
                const instName = instSnap.exists() ? (instSnap.data().schoolName || instSnap.data().name) : "Unknown Institution";

                // Set Approved = False, Update linked Institution
                await setDoc(doc(db, collectionName, userId), {
                    institutionName: instName,
                    approved: false
                }, { merge: true });

                // CLEANUP: Cancel/Delete ALL previous 'waiting' admission requests to avoid confusion
                // (e.g. if I applied to School A, then changed to School B, School A request should die)
                try {
                    const qAdmissions = query(
                        collection(db, "admissions"),
                        where("userId", "==", userId),
                        where("status", "==", "waiting")
                    );
                    const snapAdmissions = await getDocs(qAdmissions);
                    const cleanupPromises = [];
                    snapAdmissions.forEach((d) => {
                        console.log(`Deleting obsolete admission request: ${d.id}`);
                        cleanupPromises.push(deleteDoc(d.ref));
                    });
                    if (cleanupPromises.length > 0) await Promise.all(cleanupPromises);
                } catch (cleanupErr) {
                    console.warn("Cleanup of old admissions failed (non-fatal):", cleanupErr);
                }

                // Create Admission Request
                await addDoc(collection(db, "admissions"), {
                    name: newDisplayName,
                    role: role,
                    [role === 'teacher' ? 'subject' : 'age']: role === 'teacher' ? (formData.subject || 'General') : (formData.dob ? new Date().getFullYear() - new Date(formData.dob).getFullYear() : 'N/A'),
                    class: formData.class || '',
                    institutionId: formData.institutionId,
                    institutionName: instName,
                    userId: userId,
                    status: 'waiting',
                    joinedAt: new Date()
                });

                setUserData(prev => ({ ...prev, approved: false })); // Lock UI
                navigate('/pending-approval');
            } else if (role === 'institution') {
                // New Institution Registration Logic
                await setDoc(doc(db, "institutions", userId), {
                    approved: false
                }, { merge: true });

                setUserData(prev => ({ ...prev, approved: false }));
                navigate('/pending-approval');
            }


        } catch (err) {
            console.error("Submission Error:", err);
            alert("Error saving: " + err.message);
        }
    };

    if (loading) return <div className="container">Loading...</div>;

    return (
        <div className="container">
            <button
                onClick={handleBack}
                style={{
                    display: 'flex',
                    alignItems: 'center',
                    background: 'none',
                    border: 'none',
                    cursor: 'pointer',
                    fontSize: '16px',
                    color: '#6c5ce7',
                    fontWeight: 'bold',
                    marginBottom: '10px'
                }}
            >
                â† Back
            </button>
            <header className="details-header">
                {role ? `${role.charAt(0).toUpperCase() + role.slice(1)} Profile Setup` : 'Complete Your Profile'}
            </header>

            <div className="card details-card">
                <form onSubmit={handleSubmit}>

                    {/* 1. ROLE SELECTION (Show ONLY if role is not set) */}
                    {!role && (
                        <div className="form-group fallback-role-box" style={{ background: '#fff3cd', padding: '20px', borderRadius: '10px', border: '1px solid #ffeeba' }}>
                            <h3 style={{ marginTop: 0, color: '#856404' }}>Welcome! Please select your path:</h3>
                            <p style={{ fontSize: '14px', color: '#856404' }}>To customize your profile, we need to know who you are.</p>

                            <label className="warning-label" style={{ display: 'block', marginBottom: '10px' }}>I am a:</label>
                            <select value={role} onChange={(e) => setRole(e.target.value)} className="input-field" style={{ fontSize: '16px', padding: '10px' }} required>
                                <option value="">-- Choose Your Role --</option>
                                <option value="student">ðŸ‘¨â€ðŸŽ“ Student</option>
                                <option value="teacher">ðŸ‘©â€ðŸ« Teacher</option>
                                <option value="institution">ðŸ« Institution / School</option>
                            </select>
                        </div>
                    )}

                    {/* 2. FORM FIELDS (Show ONLY if role is set) */}
                    {role && (
                        <div className="role-specific-form fade-in">
                            <div className="role-status-box" style={{ marginBottom: '20px', padding: '10px', background: '#e2e6ea', borderRadius: '5px' }}>
                                <strong>Selected Role:</strong> {role.toUpperCase()}
                                <span onClick={() => { if (!passedRole) setRole(''); }} style={{ float: 'right', cursor: 'pointer', color: 'blue', fontSize: '12px', textDecoration: 'underline' }}>
                                    {!passedRole && "(Change)"}
                                </span>
                            </div>

                            {/* Teacher Fields */}
                            {role === 'teacher' && (
                                <div className="form-group">
                                    <h3 style={{ borderBottom: '2px solid #0984e3', paddingBottom: '5px', marginBottom: '15px', color: '#0984e3' }}>ðŸ‘¨â€ðŸ« Teacher Details</h3>

                                    <label>First Name</label>
                                    <input name="firstName" value={formData.firstName || ''} className="input-field" required onChange={handleChange} />

                                    <label>Second Name</label>
                                    <input name="secondName" value={formData.secondName || ''} className="input-field" required onChange={handleChange} />

                                    <label>Subject Specialization</label>
                                    <input
                                        name="subject"
                                        value={formData.subject || ''}
                                        className="input-field"
                                        placeholder="e.g. Mathematics, Science"
                                        required
                                        onChange={handleChange}
                                    // Subject is now editable by Teacher
                                    />
                                    {/* <p style={{ fontSize: '11px', color: '#d63031', marginTop: '-5px' }}>* Subject is assigned by Institution</p> */}

                                    <label>Gender</label>
                                    <select name="gender" value={formData.gender || ''} className="input-field" onChange={handleChange}>
                                        <option value="" disabled>Select Gender</option>
                                        <option>Male</option><option>Female</option><option>Other</option>
                                    </select>

                                    <label>Age (Date of Birth)</label>
                                    <input type="date" name="dob" value={formData.dob || ''} className="input-field" required onChange={handleChange} />

                                    <label className="text-muted">Experience</label>
                                    <div className="experience-container">
                                        <select name="expYears" value={formData.expYears || '0 Years'} className="input-field" onChange={handleChange}>
                                            <option>0 Years</option><option>1 Year</option><option>2 Years</option><option>3 Years</option><option>4 Years</option><option>5+ Years</option>
                                        </select>
                                        <select name="expMonths" value={formData.expMonths || '0 Months'} className="input-field" onChange={handleChange}>
                                            <option>0 Months</option><option>6 Months</option><option>11 Months</option>
                                        </select>
                                    </div>

                                    <label className="checkbox-label">
                                        <input type="checkbox" name="noExp" checked={formData.noExp || false} onChange={handleChange} /> No Experience
                                    </label>

                                    <label style={{ color: '#d63031', fontWeight: 'bold', marginTop: '15px' }}>Apply to School/Institution:</label>
                                    {institutions.length === 0 && <p style={{ color: 'red', fontSize: '12px' }}>No registered institutions found. You cannot submit without selecting one.</p>}
                                    <p style={{ fontSize: '12px', color: '#666', marginTop: '-5px', marginBottom: '10px' }}>Select the school you want to join. They will receive your application.</p>
                                    <select
                                        name="institutionId"
                                        value={formData.institutionId || ''}
                                        className="input-field"
                                        required
                                        onChange={handleChange}
                                        disabled={!!initialData.institutionId && initialData.approved === true} // Allow edit if NOT approved
                                    >
                                        <option value="" disabled>Select a School to Apply</option>
                                        {institutions.map(inst => (
                                            <option key={inst.id} value={inst.id}>{inst.schoolName || inst.name || "Unnamed"}</option>
                                        ))}
                                    </select>
                                </div>
                            )}

                            {/* Student Fields */}
                            {role === 'student' && (
                                <div className="form-group">
                                    <h3 style={{ borderBottom: '2px solid #00b894', paddingBottom: '5px', marginBottom: '15px', color: '#00b894' }}>ðŸŽ“ Student Details</h3>

                                    <label>First Name</label>
                                    <input name="firstName" value={formData.firstName || ''} className="input-field" required onChange={handleChange} />

                                    <label>Second Name</label>
                                    <input name="secondName" value={formData.secondName || ''} className="input-field" required onChange={handleChange} />

                                    <label>Class</label>
                                    <select name="class" value={formData.class || 'Nursery'} className="input-field" onChange={handleChange}>
                                        <option>Nursery</option>
                                        {['LKG', 'UKG', '1st', '2nd', '3rd', '4th', '5th', '6th', '7th', '8th', '9th', '10th'].map(c => <option key={c} value={c}>{c}</option>)}
                                    </select>

                                    <label style={{ color: '#d63031', fontWeight: 'bold', marginTop: '15px' }}>Apply to School/Institution:</label>
                                    {institutions.length === 0 && <p style={{ color: 'red', fontSize: '12px' }}>No registered institutions found. You cannot submit without selecting one.</p>}
                                    <select
                                        name="institutionId"
                                        value={formData.institutionId || ''}
                                        className="input-field"
                                        required
                                        onChange={handleChange}
                                        disabled={!!initialData.institutionId && initialData.approved === true} // Allow edit if NOT approved
                                    >
                                        <option value="" disabled>Select a School to Apply</option>
                                        {institutions.map(inst => (
                                            <option key={inst.id} value={inst.id}>{inst.schoolName || inst.name || "Unnamed"}</option>
                                        ))}
                                    </select>

                                    <label>Gender</label>
                                    <select name="gender" value={formData.gender || ''} className="input-field" onChange={handleChange}>
                                        <option value="" disabled>Select Gender</option>
                                        <option>Male</option><option>Female</option><option>Other</option>
                                    </select>

                                    <label>Age (Date of Birth)</label>
                                    <input type="date" name="dob" value={formData.dob || ''} className="input-field" required onChange={handleChange} />

                                    <label className="text-muted">Father Name</label>
                                    <input name="fatherName" value={formData.fatherName || ''} className="input-field" onChange={handleChange} />

                                    <label className="text-muted">Mother Name</label>
                                    <input name="motherName" value={formData.motherName || ''} className="input-field" onChange={handleChange} />

                                    <label className="text-muted">Prizes</label>
                                    <textarea name="prizes" value={formData.prizes || ''} className="input-field" placeholder="Mention prizes received, if any" onChange={handleChange}></textarea>
                                </div>
                            )}

                            {/* Institution Fields */}
                            {role === 'institution' && (
                                <div className="form-group">
                                    <h3 style={{ borderBottom: '2px solid #6c5ce7', paddingBottom: '5px', marginBottom: '15px', color: '#6c5ce7' }}>ðŸ« Institution Registration</h3>

                                    <label>Chairman Name</label>
                                    <input name="chairmanName" value={formData.chairmanName || ''} className="input-field" required onChange={handleChange} />

                                    <label>Principal Name</label>
                                    <input name="principalName" value={formData.principalName || ''} className="input-field" required onChange={handleChange} />

                                    <label>School Name</label>
                                    <input name="schoolName" value={formData.schoolName || ''} className="input-field" required onChange={handleChange} />

                                    <label>Establishment Year</label>
                                    <input type="date" name="estYear" value={formData.estYear || ''} className="input-field" required onChange={handleChange} />

                                    <label className="text-muted">Chairman Profile Link <span style={{ fontSize: '12px', color: '#888' }}>(Optional)</span></label>
                                    <input type="url" name="chairmanLink" value={formData.chairmanLink || ''} className="input-field" onChange={handleChange} />

                                    <label className="text-muted">Principal Profile Link <span style={{ fontSize: '12px', color: '#888' }}>(Optional)</span></label>
                                    <input type="url" name="principalLink" value={formData.principalLink || ''} className="input-field" onChange={handleChange} />

                                    <h4 className="section-header">ðŸ“ž Institution Contact Details</h4>
                                    <p className="text-muted help-text">This will be visible to students for admissions/inquiries.</p>

                                    <label>Official Phone Number</label>
                                    <input name="phoneNumber" type="tel" value={formData.phoneNumber || ''} className="input-field" placeholder="+91 9876543210" required onChange={handleChange} />

                                    <label className="checkbox-label-sm">
                                        <input
                                            type="checkbox"
                                            onChange={(e) => {
                                                if (e.target.checked) {
                                                    setFormData(prev => ({ ...prev, whatsappNumber: prev.phoneNumber }));
                                                }
                                            }}
                                        />
                                        WhatsApp number is same as Phone Number
                                    </label>

                                    <label>WhatsApp Number</label>
                                    <input name="whatsappNumber" type="tel" value={formData.whatsappNumber || ''} className="input-field" placeholder="+91 9876543210" required onChange={handleChange} />

                                    <h4 className="section-header">ðŸš‘ Emergency & Safety Contacts</h4>
                                    <p className="text-muted help-text">These numbers will be shown to your students in the Report Harassment page.</p>

                                    <label>Local Police Station Name</label>
                                    <input name="localPoliceName" value={formData.localPoliceName || ''} className="input-field" placeholder="e.g. Banjara Hills PS" required onChange={handleChange} />

                                    <label>Local Police Phone Number</label>
                                    <input name="localPolicePhone" value={formData.localPolicePhone || ''} className="input-field" placeholder="e.g. 040-23456789" required onChange={handleChange} />
                                </div>
                            )}
                            <div className="submit-container">
                                <button type="submit" className="btn submit-button">Submit Details</button>
                            </div>
                        </div>
                    )}
                </form>

                {/* Debug Info Removed for Security */}
            </div>
        </div>
    );
}

--- END OF FILE: src/pages/Details.jsx ---

--- START OF FILE: src/context/UserContext.jsx ---
import React, { createContext, useContext, useState, useEffect } from 'react';
import { auth, db } from '../firebase';
import { onAuthStateChanged } from 'firebase/auth';
import { doc, getDoc, onSnapshot } from 'firebase/firestore';
import { registerSession, clearLocalSession } from '../utils/sessionManager';

const UserContext = createContext();

export function UserProvider({ children }) {
    const [user, setUser] = useState(null);
    const [userData, setUserData] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        let unsubscribeSnapshot = null;
        let unsubscribeSession = null;
        let retryCount = 0;
        const MAX_RETRIES = 3;

        // Failsafe: Force stop loading after 6 seconds
        const failsafe = setTimeout(() => {
            setLoading((prev) => {
                if (prev) {
                    console.log("Force clearing loading state due to timeout.");
                    return false;
                }
                return prev;
            });
        }, 6000);

        const unsubscribeAuth = onAuthStateChanged(auth, async (currentUser) => {
            console.log("Auth State Changed:", currentUser ? "User Logged In" : "User Logged Out");
            setUser(currentUser);

            // Cleanup
            if (unsubscribeSnapshot) { unsubscribeSnapshot(); unsubscribeSnapshot = null; }
            if (unsubscribeSession) { unsubscribeSession(); unsubscribeSession = null; }

            if (currentUser) {
                setLoading(true);

                // Session Management
                registerSession(currentUser.uid).then((sessionId) => {
                    if (sessionId) {
                        const sessionRef = doc(db, 'users', currentUser.uid, 'sessions', sessionId);
                        unsubscribeSession = onSnapshot(sessionRef, (docSnap) => {
                            if (!docSnap.exists()) {
                                console.log("Session revoked.");
                                auth.signOut().then(() => {
                                    clearLocalSession();
                                    alert("Session expired/revoked.");
                                });
                            }
                        });
                    }
                }).catch(e => console.error("Session Error:", e));

                // 2. Detection Logic (Original Stable Logic)
                const detectFull = async () => {
                    if (retryCount >= MAX_RETRIES) {
                        setUserData(null);
                        setLoading(false);
                        return;
                    }
                    retryCount++;

                    // Parallel Check
                    const instRef = doc(db, "institutions", currentUser.uid);
                    const teachRef = doc(db, "teachers", currentUser.uid);
                    const userRef = doc(db, "users", currentUser.uid);

                    try {
                        const results = await Promise.allSettled([
                            getDoc(instRef),
                            getDoc(teachRef),
                            getDoc(userRef)
                        ]);

                        const instSnap = results[0].status === 'fulfilled' ? results[0].value : { exists: () => false };
                        const teachSnap = results[1].status === 'fulfilled' ? results[1].value : { exists: () => false };
                        const userSnap = results[2].status === 'fulfilled' ? results[2].value : { exists: () => false };

                        if (instSnap.exists()) {
                            // 1. Set Data IMMEDIATELY
                            setUserData({ ...instSnap.data(), uid: currentUser.uid, role: (instSnap.data().role || 'institution').toLowerCase() });
                            setLoading(false);
                            sessionStorage.setItem('user_collection_cache', 'institutions');

                            // 2. Subscribe for updates
                            unsubscribeSnapshot = onSnapshot(instRef, (d) => {
                                if (!d.exists()) { detectFull(); return; }
                                setUserData({ ...d.data(), uid: currentUser.uid, role: (d.data().role || 'institution').toLowerCase() });
                            });
                        } else if (teachSnap.exists()) {
                            // 1. Set Data IMMEDIATELY
                            setUserData({ ...teachSnap.data(), uid: currentUser.uid, role: (teachSnap.data().role || 'teacher').toLowerCase() });
                            setLoading(false);
                            sessionStorage.setItem('user_collection_cache', 'teachers');

                            // 2. Subscribe
                            unsubscribeSnapshot = onSnapshot(teachRef, (d) => {
                                if (!d.exists()) { detectFull(); return; }
                                setUserData({ ...d.data(), uid: currentUser.uid, role: (d.data().role || 'teacher').toLowerCase() });
                            });
                        } else if (userSnap.exists()) {
                            // 1. Set Data IMMEDIATELY
                            setUserData({ ...userSnap.data(), uid: currentUser.uid, role: (userSnap.data().role || 'student').toLowerCase() });
                            setLoading(false);
                            sessionStorage.setItem('user_collection_cache', 'users');

                            // 2. Subscribe
                            unsubscribeSnapshot = onSnapshot(userRef, (d) => {
                                if (!d.exists()) { detectFull(); return; }
                                setUserData({ ...d.data(), uid: currentUser.uid, role: (d.data().role || 'student').toLowerCase() });
                            });
                        } else {
                            console.log("No profile found.");
                            setUserData(null);
                            setLoading(false);
                        }
                    } catch (e) {
                        console.error("Detection Error", e);
                        setLoading(false);
                    }
                };

                // --- OPTIMIZATION: Instant Load from Profile Cache ---
                const cachedProfileJSON = sessionStorage.getItem('user_profile_cache');
                if (cachedProfileJSON) {
                    try {
                        const cachedProfile = JSON.parse(cachedProfileJSON);
                        if (cachedProfile && cachedProfile.uid === currentUser.uid) {
                            console.log("Instant Load: Using cached profile.");
                            setUserData(cachedProfile);
                            setLoading(false);
                        }
                    } catch (e) {
                        console.error("Cache parsing error", e);
                    }
                }

                // Internal helper to update state and cache
                const updateUserData = (data) => {
                    setUserData(data);
                    try {
                        sessionStorage.setItem('user_profile_cache', JSON.stringify(data));
                    } catch (e) {
                        console.warn("Storage full?", e);
                    }
                };

                // OPTIMIZATION: Check Collection Cache First (Background Validation)
                const cachedCollection = sessionStorage.getItem('user_collection_cache');

                if (cachedCollection) {
                    console.log("Verifying with cached collection:", cachedCollection);
                    unsubscribeSnapshot = onSnapshot(doc(db, cachedCollection, currentUser.uid), (d) => {
                        if (d.exists()) {
                            const data = d.data();
                            let role = data.role;
                            if (!role) {
                                if (cachedCollection === 'institutions') role = 'institution';
                                else if (cachedCollection === 'teachers') role = 'teacher';
                                else role = 'student';
                            }
                            const completeProfile = { ...data, uid: currentUser.uid, role: role.toLowerCase() };

                            // Update State & Cache
                            updateUserData(completeProfile);
                            setLoading(false); // Ensure loading is off
                        } else {
                            // Validation failed - clear bad cache
                            sessionStorage.removeItem('user_collection_cache');
                            sessionStorage.removeItem('user_profile_cache');
                            if (!cachedProfileJSON) { // Only fallback if we don't have a cache shown
                                detectFull();
                            } else {
                                // We are showing cached data that is now invalid! Re-run detect.
                                detectFull();
                            }
                        }
                    }, (err) => {
                        console.error("Cache subscribe error", err);
                        // If we didn't have a cache, fallback.
                        if (!cachedProfileJSON) detectFull();
                    });
                } else {
                    // No collection cache? Run full detect
                    detectFull();
                }

            } else {
                setUserData(null);
                setLoading(false);
                sessionStorage.removeItem('user_collection_cache');
                sessionStorage.removeItem('user_profile_cache');
            }
        });

        return () => {
            clearTimeout(failsafe);
            unsubscribeAuth();
            if (unsubscribeSnapshot) unsubscribeSnapshot();
            if (unsubscribeSession) unsubscribeSession();
        };
    }, []);

    const values = React.useMemo(() => ({
        user, userData, loading, setUserData
    }), [user, userData, loading]);

    const handleLogout = () => {
        auth.signOut();
        sessionStorage.clear();
        window.location.reload();
    };

    return (
        <UserContext.Provider value={values}>
            {children}
        </UserContext.Provider>
    );
}

export function useUser() {
    return useContext(UserContext);
}

--- END OF FILE: src/context/UserContext.jsx ---

--- START OF FILE: src/context/ThemeContext.jsx ---
import React, { createContext, useContext, useState, useEffect } from 'react';

const ThemeContext = createContext();

export const useTheme = () => useContext(ThemeContext);

export const ThemeProvider = ({ children }) => {
    // Default to light, or read from local storage
    const [theme, setTheme] = useState(() => {
        const savedTheme = localStorage.getItem('app-theme');
        return savedTheme || 'Light';
    });

    useEffect(() => {
        // Update the data-theme attribute on the root element
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('app-theme', theme);
    }, [theme]);

    const toggleTheme = () => {
        setTheme(prevTheme => prevTheme === 'Light' ? 'Dark' : 'Light');
    };

    return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
            {children}
        </ThemeContext.Provider>
    );
};

--- END OF FILE: src/context/ThemeContext.jsx ---

--- START OF FILE: src/components/MainLayout.jsx ---
import React, { useState, useEffect } from 'react';
import { Outlet, useLocation } from 'react-router-dom';
import Header from './Header';
import Sidebar from './Sidebar';
import { useUser } from '../context/UserContext';
import BottomNav from './BottomNav';
import AnnouncementBar from './AnnouncementBar';

export default function MainLayout() {
    const { userData } = useUser();
    const location = useLocation();

    // Sidebar State
    const [isSidebarOpen, setIsSidebarOpen] = useState(window.innerWidth > 900);

    // Responsive Sidebar
    useEffect(() => {
        const handleResize = () => {
            if (window.innerWidth < 900) setIsSidebarOpen(false);
            else setIsSidebarOpen(true);
        };
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);





    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            {/* 1. Sticky Header */}
            <Header onToggleSidebar={() => setIsSidebarOpen(!isSidebarOpen)} />

            {/* 2. Flex Body */}
            <div style={{ display: 'flex', flex: 1 }}>

                {/* 3. Sidebar (Left) - Desktop Only via CSS */}
                <div className="sidebar-wrapper">
                    <Sidebar isOpen={isSidebarOpen} />
                </div>

                {/* 4. Main Content (Right) */}
                <main className="main-content-area">


                    {/* Announcement Bar (Global) */}
                    <AnnouncementBar leftIcon={false} />


                    <Outlet />
                </main>
            </div>

            {/* 5. Bottom Nav - Mobile Only via CSS */}
            <div className="bottom-nav-wrapper">
                <BottomNav />
            </div>
        </div>
    );
}

--- END OF FILE: src/components/MainLayout.jsx ---

--- START OF FILE: src/components/Loading.jsx ---
(File not found)
--- END OF FILE: src/components/Loading.jsx ---
